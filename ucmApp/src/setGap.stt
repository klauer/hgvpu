program setGap
        option +d;
        option -c;
        option +r;


/** Program initialization **/
/* C includes and method prototypes */
%{
#include <epicsThread.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <epicsString.h>
#include <epicsStdio.h>
#include <asynOctetSyncIO.h>

#define inputEos "\r"
#define outputEos " "
#define BUF_SIZE 200

static int writeRead(SS_ID ssId, struct UserVar *pVar, char *command, char *reply, char *stateName);
static int getMotorMoving(SS_ID ssId, struct UserVar *pVar);
static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar);
}%

/*
 * If DIRECT CONTROL = 1, we are bypassing virtual record and communicating straight with the controller
 * if DIRECT_CONTROL = 0, we are controling through individual motor record and defered move
 */
int DIRECT_CONTROL = 1;

/** SNL variables  **/
/* Configuration and communication */
char stringOut[200];
char stringIn[200];
char abortCommand[200];
char *asynPort;
char *pasynUser;
int sg_status;
int am_status;
int n;
int initStatus = 0;
int numAxes;
int movingLarger;

/* HXU strongback distances in mm */
/* distance beetween upstream end and downstream end */
//double distEndToEnd = 3419.05;
/* distance between upstream end and upstream motor */
//double distToUsMtr =  850.0;
/* distance between upstream end and downstream motor */
//double distToDsMtr = 2550.0;
/* distance between upstream motor and downstream motor */
//double distBtwnMtr = 1700.0;

/* HXU specific conversion factor (from ANL database) */
/* Device End to Motor conversion factor */
double EndMotFactor = 0.76670;
/* Linear Encoder to Motor conversion factor */
double LinMotFactor = 0.76670;
/* Motor to Device End conversion factor */
double MotEndFactor = 1.437386;


/* Positions and new values */
double desiredGapTemp;
double deadbandTemp;
double desiredUsGap;
double desiredDsGap;
double desiredUsMotorPosition;
double desiredDsMotorPosition;
double usaMotorAmountToMove;
double uswMotorAmountToMove;
double dsaMotorAmountToMove;
double dswMotorAmountToMove;
double moveFraction;

double usaPos;
double uswPos;
double dsaPos;
double dswPos;
int usaPos_raw;
int uswPos_raw;
int dsaPos_raw;
int dswPos_raw;
int moveVelo_raw;
int acclDccl_raw;

int sampleRate;
double scalingFactorVelo;
double scalingFactorAD;

/* Setpoint PVs */
double desiredGap;        assign desiredGap   to "{DEV}:GAP_DES";
double desiredTaper;      assign desiredTaper to "{DEV}:TAPER_DES";

/* Position readback PVs */
double actualGap;         assign actualGap to "{DEV}:Gap";                      monitor actualGap;
double calcUsGap;         assign calcUsGap to "{DEV}:USGap";                    monitor calcUsGap;
double calcDsGap;         assign calcDsGap to "{DEV}:DSGap";                    monitor calcDsGap;
//TODO: create records
double calcAisleTaper;    assign calcAisleTaper to "{DEV}:AisleTaper";              monitor calcAisleTaper;
double calcWallTaper;     assign calcWallTaper to "{DEV}:WallTaper";               monitor calcWallTaper;
double calcUsSymmetry;    assign calcUsSymmetry to "{DEV}:USSymmetry";              monitor calcUsSymmetry;
double calcDsSymmetry;    assign calcDsSymmetry to "{DEV}:DSSymmetry";              monitor calcDsSymmetry;

/* Hardware position readback PVs */
double usaHalfGapEncoder; assign usaHalfGapEncoder to "{DEV}:USALinearEncoder"; monitor usaHalfGapEncoder;
double uswHalfGapEncoder; assign uswHalfGapEncoder to "{DEV}:USWLinearEncoder"; monitor uswHalfGapEncoder;
double dsaHalfGapEncoder; assign dsaHalfGapEncoder to "{DEV}:DSALinearEncoder"; monitor dsaHalfGapEncoder;
double dswHalfGapEncoder; assign dswHalfGapEncoder to "{DEV}:DSWLinearEncoder"; monitor dswHalfGapEncoder;
double usFullGapEncoder;  assign usFullGapEncoder  to "{DEV}:USGapEncoder";     monitor usFullGapEncoder;
double dsFullGapEncoder;  assign dsFullGapEncoder  to "{DEV}:DSGapEncoder";     monitor dsFullGapEncoder;

/* Motor position setpoint */
double usaMotorVal;       assign usaMotorVal to "{DEV}:USAMotor.VAL";           monitor usaMotorVal;
double uswMotorVal;       assign uswMotorVal to "{DEV}:USWMotor.VAL";           monitor uswMotorVal;
double dsaMotorVal;       assign dsaMotorVal to "{DEV}:DSAMotor.VAL";           monitor dsaMotorVal;
double dswMotorVal;       assign dswMotorVal to "{DEV}:DSWMotor.VAL";           monitor dswMotorVal;
/* Motor position readback */
double usaMotorRbk;       assign usaMotorRbk to "{DEV}:USAMotor.RBK";           monitor usaMotorRbk;
double uswMotorRbk;       assign uswMotorRbk to "{DEV}:USWMotor.RBK";           monitor uswMotorRbk;
double dsaMotorRbk;       assign dsaMotorRbk to "{DEV}:DSAMotor.RBK";           monitor dsaMotorRbk;
double dswMotorRbk;       assign dswMotorRbk to "{DEV}:DSWMotor.RBK";           monitor dswMotorRbk;
/* Motor position calculated from encoder */
double usaMotorGap;       assign usaMotorGap to "{DEV}:USAMotorGap";            monitor usaMotorGap;
double uswMotorGap;       assign uswMotorGap to "{DEV}:USWMotorGap";            monitor uswMotorGap;
double dsaMotorGap;       assign dsaMotorGap to "{DEV}:DSAMotorGap";            monitor dsaMotorGap;
double dswMotorGap;       assign dswMotorGap to "{DEV}:DSWMotorGap";            monitor dswMotorGap;
double motorResolution;   assign motorResolution to "{DEV}:USAMotor.MRES";

/* Move precision and retry */
double deadband;          assign deadband to "{DEV}:DEADBAND";
double moveFrac;          assign moveFrac to "{DEV}:MOVEFRAC";
double moveVelo;          assign moveVelo to "{DEV}:MOVEVELO";
//TODO: Create record for this acceleration paramter ( if using DIRECT_CONTROL of the motor)
double acclDccl;          assign acclDccl to "{DEV}:MOVEACCL";
double dlyInput;          assign dlyInput to "{DEV}:DLYINPUT";                  monitor dlyInput;
double dly;               assign dly to "{DEV}:DLY";                            monitor dly;
int rtry;                 assign rtry to "{DEV}:RETRY";                         monitor rtry;
int rtryMax;              assign rtryMax to "{DEV}:RETRYMAX";                   monitor rtryMax;

/* Command and status PVs */
int startGapAdjustment;   assign startGapAdjustment to "{DEV}:GO";              monitor startGapAdjustment;
int abort;                assign abort to "{DEV}:Abort.VAL";                    monitor abort;
int stop;                 assign stop to "{DEV}:STOP";                          monitor stop;
int dmov;                 assign dmov to "{DEV}:GAP_DMOV";                      monitor dmov;
int singleApproach;       assign singleApproach to "{DEV}:SINGLE_APPROACH";     monitor singleApproach;
int autoBrake;            assign autoBrake to "{DEV}:AUTOBRAKE";                monitor autoBrake;
int calibMotors;          assign calibMotors to "{DEV}:CalibrateMotors.PROC";
int triggerDefer;         assign triggerDefer to "{DEV}:GapMotor:Trig.PROC";    

/* Debug and simulation PVs */
int debugLevel;           assign debugLevel to "{DEV}:DebugLevel.VAL";          monitor debugLevel;
int simMode;              assign simMode to "{DEV}:SimMode.VAL";                monitor simMode;
string setGapState;       assign setGapState to "{DEV}:SETGAP_STATE.VAL";
string abortState;        assign abortState to "{DEV}:ABORT_STATE.VAL";


/* stateSet to change gap */
ss setGap
{
  /* Initialize state */
  state init {
    entry {
      if (debugLevel) printf("setGap:init: entry\n");
      n = sprintf(setGapState, "setGap:init");
      pvPut(setGapState, SYNC);
      sg_status = 0;
      /* Initialization of variables and PVs */
      /*initStatus = 0;*/
      stop = 0;
      pvPut(stop);
      rtry = 0;
      pvPut(rtry);

      desiredUsGap=0;
      desiredDsGap=0;
      desiredUsMotorPosition=0;
      desiredDsMotorPosition=0;
      usaMotorAmountToMove=0;
      uswMotorAmountToMove=0;
      dsaMotorAmountToMove=0;
      dswMotorAmountToMove=0;
      moveFraction=0.9;
      usaPos=0;
      uswPos=0;
      dsaPos=0;
      dswPos=0;
      usaPos_raw=0;
      uswPos_raw=0;
      dsaPos_raw=0;
      dswPos_raw=0;
      moveVelo_raw=0;
      acclDccl_raw=0;
      movingLarger = 0;
      startGapAdjustment = 0;
      pvPut(startGapAdjustment);
      dmov = 1;
      pvPut(dmov);
      numAxes = 4;

      /* Creating ABORT string */
      n = sprintf(abortCommand, "S:0");

      /* Connecting to ASYN port for motors */
      asynPort = macValueGet("PORT");
      %%pVar->sg_status = pasynOctetSyncIO->connect(pVar->asynPort, 0, (asynUser **)&pVar->pasynUser, NULL);
      if (sg_status != 0) {
        printf("trajectoryScan error in pasynOctetSyncIO->connect\n");
        printf("   sg_status=%d, port=%s\n", sg_status, asynPort);
      }

      /* Retrive sampling rate of the motor */
      sprintf(stringOut, "RSAMP:1");
      %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
      sampleRate = atoi(stringIn);
      /* Set scaling factor for velocity and acceleration */
      scalingFactorVelo = 65536 / sampleRate;
      scalingFactorAD = scalingFactorVelo / sampleRate;

      if (initStatus == 0) initStatus = 1;
      if (debugLevel) printf("setGap:init: done; going to 'idle'\n");
    }

    /* Continue to idle state */
    when () {
    } state idle
  }

  /* Idle state and on change of EPICS PVs preform action */
  state idle {
    entry {
      if (debugLevel) printf("setGap:idle: entry\n");
      n = sprintf(setGapState, "setGap:idle");
      pvPut(setGapState, SYNC);
      /* Clear flags that indicate/start motion */
      startGapAdjustment = 0;
      pvPut(startGapAdjustment);
      dmov = 1;
      pvPut(dmov);
      movingLarger = 0;
    }

    /* writeRead() has failed in the transition leading to this state*/
    when(sg_status != 0) {
      printf(" setGap:idle ERROR: previous writeRead() returned %d. Going to idle.\n", sg_status);
      sg_status = 0;
    } state idle

    /* If stop is issued */
    when(stop == 1) {
      if (debugLevel) printf("setGap:idle: going to 'stop'\n");
    } state stop

    /* When motors are commanded to GO */
    when( startGapAdjustment == 1 ) {
      /* Retrieve PV values */
      pvGet(desiredGap,SYNC);
      pvGet(desiredTaper,SYNC);
      pvGet(deadband,SYNC);
      pvGet(moveFrac,SYNC);
      pvGet(moveVelo,SYNC);
      pvGet(motorResolution,SYNC);
      /* Clear retries and Go flag */
      rtry = 0;
      pvPut(rtry);
      startGapAdjustment = 0;
      pvPut(startGapAdjustment);
      dmov = 0;
      pvPut(dmov);

      /* If single approach and opening gap */
      if( (desiredGap > actualGap) && (singleApproach == 1) ) {
        /* Store desired gap and deadband */
        desiredGapTemp = desiredGap;
        deadbandTemp = deadband;
        /* Enlarge desired gap and deadband for single approach inital move */
        desiredGap = desiredGap + 1;
        deadband = 0.5;
        movingLarger = 1;
      }
      if (debugLevel) printf("setGap:idle: going to 'calcMove'\n");
    } state calcMove
  }

  /* State for calculating new motor positions */
  state calcMove {
    entry {
      if (debugLevel) printf("setGap:calcMove: entry'\n");
      n = sprintf(setGapState, "setGap:calcMove");
      pvPut(setGapState, SYNC);
    }

    /* writeRead() has failed in the transition leading to this state*/
    when(sg_status != 0) {
      printf(" setGap:calcMove ERROR: previous writeRead() returned %d. Going to idle.\n", sg_status);
    } state idle

    /* Disable retry checking for time based gap setting */
    when(rtry >= rtryMax) {
      if (debugLevel) printf("setGap:calcMove: rtry >= rtryMax %d >= %d\n", rtry, rtryMax);
    } state moveComplete


    /* If stop is issued */
    when(stop == 1){} state stop

    /* When in single approach and gap above modified desired gap */
    when( (movingLarger == 1) && (actualGap > (desiredGap - 0.5))) {
      if (debugLevel) printf("setGap:calcMove: single approach, above desired gap");
    } state moveComplete

    /* Calculate new positions */
    when() {
      /* Calibrate motor positions with linear encoder readback */
      calibMotors = 1;
      pvPut(calibMotors,SYNC);
      /* Wait for sync to complete and monitors to update */
      epicsThreadSleep(0.3);

      //TODO: reorganize this:
      desiredTaper = (desiredGap + desiredTaper) < 7.1 ? 0 : desiredTaper;
     
      //TODO: Discuss with SLAC and select option below:
      /* Option 1, symetrical taper around center*/
      //desiredUsGap = desiredGap - desiredTaper/2.0;
      //desiredDsGap = desiredGap + desiredTaper/2.0;
      /* Option 2, desired gap set at US side, taper adjusts only DS side */
      desiredUsGap = desiredGap;
      desiredDsGap = desiredGap + desiredTaper;
      /* Desired value for motor per side */
      desiredUsMotorPosition = desiredUsGap * EndMotFactor + desiredDsGap * (1.0 - EndMotFactor);
      desiredDsMotorPosition = desiredDsGap * EndMotFactor + desiredUsGap * (1.0 - EndMotFactor);
      
      usaMotorAmountToMove = desiredUsMotorPosition - usaMotorGap;
      uswMotorAmountToMove = desiredUsMotorPosition - uswMotorGap;
      dsaMotorAmountToMove = desiredDsMotorPosition - dsaMotorGap;
      dswMotorAmountToMove = desiredDsMotorPosition - dswMotorGap;
      
      /* Calculate factor for retries */
      if ( fabs(actualGap - desiredGap ) < 0.1 )
        moveFraction = 1.0;
      else
        moveFraction = moveFrac;

      /* Calculate new motor positions */
      usaPos = usaMotorRbk + moveFraction * usaMotorAmountToMove;
      uswPos = uswMotorRbk + moveFraction * uswMotorAmountToMove;
      dsaPos = dsaMotorRbk + moveFraction * dsaMotorAmountToMove;
      dswPos = dswMotorRbk + moveFraction * dswMotorAmountToMove;

      if ( DIRECT_CONTROL == 0 ) { 
        /* Write values to motor control */ 
        usaMotorVal = usaPos;
        pvPut(usaMotorVal);
        uswMotorVal = uswPos;
        pvPut(uswMotorVal);
        dsaMotorVal = dsaPos;
        pvPut(dsaMotorVal);
        dswMotorVal = dswPos;
        pvPut(dswMotorVal);
      }
      else {
        /* Scale new positions to raw value and push to motor */ 
        usaPos_raw = (int) usaPos * motorResolution;
        uswPos_raw = (int) uswPos * motorResolution;
        dsaPos_raw = (int) dsaPos * motorResolution;
        dswPos_raw = (int) dswPos * motorResolution;
        moveVelo_raw = (int) (moveVelo/motorResolution) * scalingFactorVelo;
        acclDccl_raw = (int) ((moveVelo * motorResolution) / acclDccl) * scalingFactorAD;
  
        /* Create a string to send to controller to start motor move */
        sprintf(stringOut, "iii:1=%d", uswPos_raw); %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
        sprintf(stringOut, "jjj:1=%d", dswPos_raw); %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
        sprintf(stringOut, "kkk:1=%d", dsaPos_raw); %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
        sprintf(stringOut, "lll:1=%d", usaPos_raw); %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
        sprintf(stringOut, "vvv:1=%d", moveVelo_raw); %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
        sprintf(stringOut, "aaa:1=%d", acclDccl_raw); %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
      }

      /* Enable motors and disable breaks */
      sprintf(stringOut, "BRKRLS:0");
      %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);

      if (debugLevel) {
        printf("setGap:calcMove: desiredGap = %f, desiredTaper = %f'\n", desiredGap, desiredTaper);
        printf("setGap:calcMove: uswPos = %f (%d)'\n", uswPos, uswPos_raw);
        printf("setGap:calcMove: dswPos = %f (%d)'\n", dswPos, dswPos_raw);
        printf("setGap:calcMove: dsaPos = %f (%d)'\n", dsaPos, dsaPos_raw);
        printf("setGap:calcMove: usaPos = %f (%d)'\n", usaPos, usaPos_raw);
        printf("setGap:calcMove: moveVelo = %f (%d)'\n", moveVelo, moveVelo_raw);
        printf("setGap:calcMove: acclDccl = %f (%d)'\n", acclDccl, acclDccl_raw);
      }
    } state move
  }

  /* State that starts the move */
  state move {
    entry {
      if (debugLevel){
        printf("setGap:move: entry\n");
        printf("Distance to move: UsWall=%f, DsWall=%f, DsAisle=%f, UsAisle=%f [mm] \n",
                                  fabs(uswMotorAmountToMove),fabs(dswMotorAmountToMove),
                                  fabs(dsaMotorAmountToMove),fabs(usaMotorAmountToMove));
      }
      n = sprintf(setGapState, "setGap:move");
      pvPut(setGapState, SYNC);
    }

    /* writeRead() has failed in the transition leading to this state*/
    when(sg_status != 0) {
      printf(" setGap:move ERROR: previous writeRead() returned %d. Going to idle.\n", sg_status);
    } state idle

    /* If stop is issued */
    when(stop == 1){} state stop

    when( (usaMotorAmountToMove < deadband) && (uswMotorAmountToMove < deadband) &&
          (dsaMotorAmountToMove < deadband) && (dswMotorAmountToMove < deadband) ) {
      epicsThreadSleep(1.5);
      if (debugLevel) printf("setGap:move: All absolute moves less than deadband. Going to moveComplete\n");
    } state moveComplete

    /* Send command to start motion */
    when( delay(0.3) ) {
      if (debugLevel) printf("setGap:move: Waiting for motion complete\n");
      /* Wait if any of the motors is moving */
      %%waitEpicsMotors(ssId, pVar);
      if (debugLevel) printf("setGap:move: Wait complete\n");
      
      if ( DIRECT_CONTROL == 0 ) {
        /* Trigger defered move */ 
        triggerDefer = 1;
        pvPut(triggerDefer,SYNC);
      }
      else {
        /* Send comand to start move */
        sprintf(stringOut, "GS");
        %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
      }
    } state moving
  }

  /* State while motors are moving */
  state moving {
    entry {
      if (debugLevel) printf("setGap:moving: entry\n");
      n = sprintf(setGapState, "setGap:moving");
      pvPut(setGapState, SYNC);
    }

    /* writeRead() has failed in the transition leading to this state*/
    when(sg_status != 0) {
      printf(" setGap:moving ERROR: previous writeRead() returned %d. Going to idle.\n", sg_status);
    } state idle

    /* If stop is issued */
    when(stop == 1){} state stop

    /* When moving */
    when(delay(0.2)){
      /*Wait while motors are moving */
      %%waitEpicsMotors(ssId, pVar);
      /* When move done, start a timeout for servoing */
      dly = 0;
      pvPut(dly);
      /* When move done, increase number of retrys */
      rtry = rtry + 1;
      pvPut(rtry);
    } state calcMove
  }

  /* State when motors finish move */
  state moveComplete {
    entry {
      if (debugLevel) printf("setGap:moveComplete: entry'\n");
      n = sprintf(setGapState, "setGap:moveComplete");
      pvPut(setGapState, SYNC);
    }

    /* writeRead() has failed in the transition leading to this state*/
    when(sg_status != 0) {
      printf(" setGap:moveComplete ERROR: previous writeRead() returned %d. Going to idle.\n", sg_status);
    } state idle

    /* If stop is issued */
    when(stop == 1){} state stop

    /* When in single approach */
    when( movingLarger == 1) {
      /* Restore original values */
      movingLarger = 0;
      desiredGap = desiredGapTemp;
      deadband = deadbandTemp;
    } state calcMove

    /* On complete move */
    when() {
      /* If automatic brake engagement is turned on */
      if (autoBrake) {
        /* Issue a global stop */
        sprintf(stringOut, "S:0");
        %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
        epicsThreadSleep(0.2);
        if ( sg_status != 0 ) {
          sprintf(stringOut, "S:0");
          %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
          epicsThreadSleep(0.2);
        }
        /* Engage brakes on all motors */
        sprintf(stringOut, "BRKENG:0");
        %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
      }
      /* Calibrate motors at final position */
      calibMotors = 1;
      pvPut(calibMotors);
    } state idle
  }

  /* Stop state */
  state stop {
    entry{
      if (debugLevel) printf("setGap:stop: entry'\n");
      n = sprintf(setGapState, "setGap:stop");
      pvPut(setGapState, SYNC);
    }

    /* On STOP flag */
    when (){
      /* Send out an Abort all axes command */
      sprintf(stringOut, "S:0");
      %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
      epicsThreadSleep(0.2);
      sprintf(stringOut, "BRKENG:0");
      %%pVar->sg_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->setGapState);
      /* Raise virtual axis done moving flag */
      dmov = 1;
      pvPut(dmov);
      /* if in single approach mode restore PVs */
      if (movingLarger == 1) {
        movingLarger = 0;
        desiredGap = desiredGapTemp;
        deadband = deadbandTemp;
      }
      /* Clear stop flag */
      stop = 0;
      pvPut(stop);

    } state idle
  }
}

/* stateSet to abort move */
ss abortMove {

  state am_init {
    /* writeRead() has failed in the transition leading to this state*/
    when(am_status != 0) {
      printf("abortMove:am_init ERROR: previous writeRead() returned %d. Going to am_init.\n", am_status);
      /* Clear status flag */
      am_status = 0;
    } state am_init

    when() {
      sprintf(abortCommand, "S:0"); 
    } state monitorAbort

  }

  state monitorAbort {
    entry{
      n = sprintf(abortState, "abortMove:monitorAbort");
      pvPut(abortState, SYNC);
   }

    /* writeRead() has failed in the transition leading to this state*/
    when(am_status != 0) {
      printf("abortMove:monitorAbort ERROR: previous writeRead() returned %d. Going to am_init.\n", am_status);
    } state am_init

    /* When Abort is triggered */
    when ((abort==1) && delay(0.1)) {
      /* Issue an abort command on controller */
      %%pVar->am_status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn, pVar->abortState);
      if (debugLevel) printf("abortMove: sent command '%s'\n", abortCommand);
      epicsThreadSleep(0.2);
      if (am_status != 0 ) {
        /* If problem with writing abort command to controller, try again */
        %%pVar->am_status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn, pVar->abortState);
        epicsThreadSleep(0.2);
      }
      /* Engage break if abort command recieved */
      sprintf(stringOut, "BRKENG:0");
      %%pVar->am_status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn, pVar->abortState);
      /* Set stop PV for main stateSet to interrupt move */
      stop = 1;
      pvPut(stop);
      /* Clear abort PV */
      abort=0;
      pvPut(abort);
    } state monitorAbort
  }
}

%{

/* WriteRead operation through asyn port */
static int writeRead(SS_ID ssId, struct UserVar *pVar, char *command, char *reply, char *stateName)
{
  asynStatus status=0;
  char buffer[BUF_SIZE];
  size_t nwrite, nread;
  int eomReason;

  if (!(pVar->simMode)) {
    status = pasynOctetSyncIO->writeRead((asynUser *)pVar->pasynUser, buffer,
             strlen(command), reply, BUF_SIZE,
             30.0, &nwrite, &nread, &eomReason);
    if (status) printf("writeRead called from %s: pasynOctetSyncIO->writeRead returned %d\n", stateName, status);
 }
  if (pVar->simMode || (pVar->debugLevel)) {
    if (buffer[strlen(buffer)-1] == '\n')
      buffer[strlen(buffer)-1] = '\0';
    printf("    writeRead:command='%s', reply='%s'\n", buffer, reply);
  }

  return(status);
}

/* Check if motors are moving */
static int getMotorMoving(SS_ID ssId, struct UserVar *pVar)
{
  char inputBuff[BUF_SIZE], outputBuff[BUF_SIZE];
  size_t nwrite, nread;
  int eomReason;
  int move_active = 0;
  int count, status, can_addr;

  #define MOVING 0x4

  for (can_addr=1, count=0; can_addr <= pVar->numAxes; can_addr++) {
    sprintf(outputBuff, "RW(0):%d", can_addr);
    status = pasynOctetSyncIO->writeRead((asynUser *)pVar->pasynUser, outputBuff,
             strlen(outputBuff), inputBuff, BUF_SIZE,
             30.0, &nwrite, &nread, &eomReason);

    if (status)
      printf("getMotorMoving: pasynOctetSyncIO->writeRead returned %d\n", status);
    move_active |= (atoi(inputBuff) & MOVING) == MOVING;
    if (pVar->debugLevel) {
      printf("getMotorMoving: outputBuff='%s'\n", outputBuff);
      printf("getMotorMoving: inputBuff='%s'\n", inputBuff);
      printf("getMotorMoving: move_active= %d\n", move_active);
    }
    if (move_active)
      return(1);
    else {
      count++;
      if (count>3) break;
    }
  }

  return(0);
}

/* Wait while motors are moving */
static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar)
{
  if(pVar->debugLevel)
    printf("waitEpicsMotors\n");
  while (getMotorMoving(ssId, pVar)) {
    epicsThreadSleep((1/5.0));
  }

 return(0);
}

}%

